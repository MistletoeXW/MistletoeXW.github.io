<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Java面试总结</title>
<meta name="keywords" content="Java面试总结, Devin">
<meta name="description" content="Java基础Java中的基本类型Java中有8种基本数据类型，分别为：

6种数字类型：
4种整数类型：byte、short、int、long
2种浮点类型：float、double


1种字符类型：char
1种布尔类型: boolea">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Java面试总结">
<meta property="og:description" content="Java基础Java中的基本类型Java中有8种基本数据类型，分别为：

6种数字类型：
4种整数类型：byte、short、int、long
2种浮点类型：float、double


1种字符类型：char
1种布尔类型: boolea">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Devin</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Java面试总结</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-05-10</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">
              面试总结
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h2><p>Java中有8种基本数据类型，分别为：</p>
<ul>
<li>6种数字类型：<ul>
<li>4种整数类型：byte、short、int、long</li>
<li>2种浮点类型：float、double</li>
</ul>
</li>
<li>1种字符类型：char</li>
<li>1种布尔类型: boolean</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">位数</th>
<th>字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">8</td>
<td>1</td>
<td>-128~127</td>
<td>0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td>2</td>
<td>-32768（-2^15） ~ 32767（2^15 - 1）</td>
<td>0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
<td>0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64</td>
<td>8</td>
<td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td>
<td>0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16</td>
<td>2</td>
<td>0 ~ 65535（2^16 - 1）</td>
<td>‘u0000’</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td>4</td>
<td>1.4E-45 ~ 3.4028235E38</td>
<td>0</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td>8</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
<td>0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td></td>
<td>true、false</td>
<td>false</td>
</tr>
</tbody></table>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p>
<h2 id="Java中基本类型和包装类型的区别"><a href="#Java中基本类型和包装类型的区别" class="headerlink" title="Java中基本类型和包装类型的区别"></a>Java中基本类型和包装类型的区别</h2><ul>
<li>用途方面：除了定义一些常量和局部变量之外，我们在其他我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong></li>
<li>存储方式：基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量存放在Java虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中</li>
<li>占用空间：相比包装类型，基本数据类型占用的空间比较小</li>
<li>默认值：成员变量包装类型不赋值则默认值为null，而基本数据类型有默认值且不是null</li>
<li>比较方式：对于基本数据类型来说，&#x3D;&#x3D;比较的是值。对于包装数据类型来说，&#x3D;&#x3D;比较的是对象的内存地址。所有整型包装类对象之间的值的比较，全部都使用equals()方法</li>
</ul>
<p>PS：<strong>数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中</p>
<h2 id="包装类型的缓存机制了解吗？"><a href="#包装类型的缓存机制了解吗？" class="headerlink" title="包装类型的缓存机制了解吗？"></a>包装类型的缓存机制了解吗？</h2><p>Java基本数据类型的包装类型大部分都用到了缓存机制来提升性能</p>
<ul>
<li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据</li>
<li>Character 创建了数值在 [0,127] 范围的缓存数据</li>
<li>Boolean 直接返回 True or False</li>
<li>两种浮点数类型的包装类 Float,Double 并没有实现缓存机制<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>PS: <strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong></p>
<h2 id="Java中自动装箱和拆箱？"><a href="#Java中自动装箱和拆箱？" class="headerlink" title="Java中自动装箱和拆箱？"></a>Java中自动装箱和拆箱？</h2><ul>
<li>装箱：将基本数据类型用它们对应的引用类型包装起来</li>
<li>拆箱：将包装类型转换为基本数据类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱:Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱:int n = i 等价于 int n = i.intValue()</span></span><br></pre></td></tr></table></figure>
PS: <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong></li>
</ul>
<h2 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h2><ul>
<li>语法形式方面：从语法形式上看，成员变量属于类，而局部变量是在代码块或者方法中定义的变量或者是方法的参数‘；成员变量可以被public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰</li>
<li>存储方式：从变量在内存中的存储方式看，如果成员变量使用static修饰，则这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的；而对象存于堆内存，局部变量则存在栈内存</li>
<li>生存时间：从变量在内存中生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随方法的调用结束而消亡</li>
<li>默认值: 从变量是否有默认值来看，成员变量如果在初始化时赋值，则会自动以类型的默认值而赋值一种情况例外:被 final 修饰的成员变量也必须显式地赋值）；而局部变量则不会自动被赋值</li>
</ul>
<h2 id="静态变量有什么作用"><a href="#静态变量有什么作用" class="headerlink" title="静态变量有什么作用"></a>静态变量有什么作用</h2><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存<br>静态变量是通过类名来访问的，例如StaticVariableExample.staticVar（如果被 private关键字修饰就无法这样访问了）</p>
<h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><ul>
<li>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li>
<li>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节</li>
</ul>
<h2 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h2><p>需要结合JVM相关知识，主要原因如下：</p>
<ul>
<li>静态方法属于类的，在类加载的时候就会分配内存，可以通过类名直接访问；而非静态成员属于实例对象，只有在对象实例化后才会存在，需要通过类的实例对象去访问</li>
<li>在类的非静态成员变量不存在的时候静态方法已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</li>
</ul>
<h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul>
<li>调用方式：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象</li>
<li>访问类成员是否存在限制：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li>重载：发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同</li>
<li>重写: 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写</li>
</ul>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象实例与对象引用区别"><a href="#对象实例与对象引用区别" class="headerlink" title="对象实例与对象引用区别"></a>对象实例与对象引用区别</h2><ul>
<li>对象实例又new进行创建，对象实例存放在堆内存中</li>
<li>对象引用指向对象实例，对象引用存放在栈内存中</li>
<li>一个对象引用可以指向0个或者1个对象</li>
<li>一个对象实例可以有n个对象引用指向它</li>
</ul>
<h2 id="对象相等与引用相等的区别"><a href="#对象相等与引用相等的区别" class="headerlink" title="对象相等与引用相等的区别"></a>对象相等与引用相等的区别</h2><ul>
<li>对象的相等一般比较的是内存中存放的内存是否相等</li>
<li>引用相等一般是比较的是他们指向的内存地址是否相等<br>区分一下&#x3D;&#x3D;和equals的在对象中使用区别</li>
<li>&#x3D;&#x3D;运算符比较的是对象的引用是否相等</li>
<li>equals比较的是对象内容是否相等，比如：比较两个字符串的内容，即使两个字符串的对象引用不同，只要内容相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 == 比较字符串的引用相等</span></span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line"><span class="comment">// 使用 equals 方法比较字符串的相等</span></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str1.equals(str3));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出============</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类的构造方法可以不声明吗？"><a href="#类的构造方法可以不声明吗？" class="headerlink" title="类的构造方法可以不声明吗？"></a>类的构造方法可以不声明吗？</h2><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作<br>如果个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了<br>构造方法特点如下：</p>
<ul>
<li>名字与类名相同</li>
<li>没有返回值，单不能用void声明构造函数</li>
<li>生成类的对象是自动执行，无需调用<br>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</li>
</ul>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法，在子类中是无法访问的</li>
<li>子类可以拥有自己的属性和方法，即子类可对父类进行扩展</li>
<li>子类可以用自己的方式实现父类方法</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态表示一个对象具有多种状态，<strong>具体表现为使用父类的引用指向子类的实例</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承(类)&#x2F;实现(接口)的关系</li>
<li>引用类型变量发出的方法调用的是哪一个类中的方法，必须要在程序运行期间才能确定</li>
<li>多态不能调用“只在子类中存在但在父类中不存在”的方法</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法</li>
</ul>
<h2 id="接口和抽象类的共同点和区别？"><a href="#接口和抽象类的共同点和区别？" class="headerlink" title="接口和抽象类的共同点和区别？"></a>接口和抽象类的共同点和区别？</h2><p>共同点：</p>
<ul>
<li>1.都不能被实例化</li>
<li>2.都可以包含抽象方法</li>
<li>3.都可以有默认的实现方法（Java 8可以使用default关键字在接口中定义默认的方法）</li>
</ul>
<p>区别：</p>
<ul>
<li>1.接口主要用于对类的行为进行约束，实现了某个接口就具有对应的行为；抽象类主要用于代码复用，强调的是所属关系</li>
<li>2.一个类只能继承一个抽象类，但可以实现多个接口</li>
<li>3.接口中的变量只能是public static final 类型的，不能被修改且必须有初始值；而抽象类的成员变量默认default，可以在子类中被重新定义，也可以被重新赋值</li>
</ul>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="top-box-text">Java基础</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="top-box-text">Java中的基本类型</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">Java中基本类型和包装类型的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="top-box-text">包装类型的缓存机制了解吗？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="top-box-text">Java中自动装箱和拆箱？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">成员变量与局部变量的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="top-box-text">静态变量有什么作用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">字符型常量和字符串常量的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%9F"><span class="top-box-text">静态方法为什么不能调用非静态成员？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="top-box-text">静态方法和实例方法有何不同？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">重载和重写的区别</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="top-box-text">面向对象</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="top-box-text">对象实例与对象引用区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">对象相等与引用相等的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%A3%B0%E6%98%8E%E5%90%97%EF%BC%9F"><span class="top-box-text">类的构造方法可以不声明吗？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="top-box-text">面向对象三大特性</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B0%81%E8%A3%85"><span class="top-box-text">封装</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF"><span class="top-box-text">继承</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%9A%E6%80%81"><span class="top-box-text">多态</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="top-box-text">接口和抽象类的共同点和区别？</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

