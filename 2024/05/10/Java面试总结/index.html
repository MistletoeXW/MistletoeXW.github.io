<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Java面试总结</title>
<meta name="keywords" content="Java面试总结, Devin">
<meta name="description" content="Java基础Java中的基本类型Java中有8种基本数据类型，分别为：

6种数字类型：
4种整数类型：byte、short、int、long
2种浮点类型：float、double


1种字符类型：char
1种布尔类型: boolea">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Java面试总结">
<meta property="og:description" content="Java基础Java中的基本类型Java中有8种基本数据类型，分别为：

6种数字类型：
4种整数类型：byte、short、int、long
2种浮点类型：float、double


1种字符类型：char
1种布尔类型: boolea">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Devin</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Java面试总结</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-05-10</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">
              面试总结
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h2><p>Java中有8种基本数据类型，分别为：</p>
<ul>
<li>6种数字类型：<ul>
<li>4种整数类型：byte、short、int、long</li>
<li>2种浮点类型：float、double</li>
</ul>
</li>
<li>1种字符类型：char</li>
<li>1种布尔类型: boolean</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">位数</th>
<th>字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">8</td>
<td>1</td>
<td>-128~127</td>
<td>0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td>2</td>
<td>-32768（-2^15） ~ 32767（2^15 - 1）</td>
<td>0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
<td>0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64</td>
<td>8</td>
<td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td>
<td>0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16</td>
<td>2</td>
<td>0 ~ 65535（2^16 - 1）</td>
<td>‘u0000’</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td>4</td>
<td>1.4E-45 ~ 3.4028235E38</td>
<td>0</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td>8</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
<td>0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td></td>
<td>true、false</td>
<td>false</td>
</tr>
</tbody></table>
<p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p>
<h2 id="Java中基本类型和包装类型的区别"><a href="#Java中基本类型和包装类型的区别" class="headerlink" title="Java中基本类型和包装类型的区别"></a>Java中基本类型和包装类型的区别</h2><ul>
<li>用途方面：除了定义一些常量和局部变量之外，我们在其他我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，<strong>包装类型可用于泛型，而基本类型不可以</strong></li>
<li>存储方式：基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量存放在Java虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中</li>
<li>占用空间：相比包装类型，基本数据类型占用的空间比较小</li>
<li>默认值：成员变量包装类型不赋值则默认值为null，而基本数据类型有默认值且不是null</li>
<li>比较方式：对于基本数据类型来说，&#x3D;&#x3D;比较的是值。对于包装数据类型来说，&#x3D;&#x3D;比较的是对象的内存地址。所有整型包装类对象之间的值的比较，全部都使用equals()方法</li>
</ul>
<p>PS：<strong>数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中</p>
<h2 id="包装类型的缓存机制了解吗？"><a href="#包装类型的缓存机制了解吗？" class="headerlink" title="包装类型的缓存机制了解吗？"></a>包装类型的缓存机制了解吗？</h2><p>Java基本数据类型的包装类型大部分都用到了缓存机制来提升性能</p>
<ul>
<li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据</li>
<li>Character 创建了数值在 [0,127] 范围的缓存数据</li>
<li>Boolean 直接返回 True or False</li>
<li>两种浮点数类型的包装类 Float,Double 并没有实现缓存机制<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>PS: <strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong></p>
<h2 id="Java中自动装箱和拆箱？"><a href="#Java中自动装箱和拆箱？" class="headerlink" title="Java中自动装箱和拆箱？"></a>Java中自动装箱和拆箱？</h2><ul>
<li>装箱：将基本数据类型用它们对应的引用类型包装起来</li>
<li>拆箱：将包装类型转换为基本数据类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱:Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱:int n = i 等价于 int n = i.intValue()</span></span><br></pre></td></tr></table></figure>
PS: <strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong></li>
</ul>
<h2 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h2><ul>
<li>语法形式方面：从语法形式上看，成员变量属于类，而局部变量是在代码块或者方法中定义的变量或者是方法的参数‘；成员变量可以被public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰</li>
<li>存储方式：从变量在内存中的存储方式看，如果成员变量使用static修饰，则这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的；而对象存于堆内存，局部变量则存在栈内存</li>
<li>生存时间：从变量在内存中生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随方法的调用结束而消亡</li>
<li>默认值: 从变量是否有默认值来看，成员变量如果在初始化时赋值，则会自动以类型的默认值而赋值一种情况例外:被 final 修饰的成员变量也必须显式地赋值）；而局部变量则不会自动被赋值</li>
</ul>
<h2 id="静态变量有什么作用"><a href="#静态变量有什么作用" class="headerlink" title="静态变量有什么作用"></a>静态变量有什么作用</h2><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存<br>静态变量是通过类名来访问的，例如StaticVariableExample.staticVar（如果被 private关键字修饰就无法这样访问了）</p>
<h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><ul>
<li>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li>
<li>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节</li>
</ul>
<h2 id="静态方法为什么不能调用非静态成员？"><a href="#静态方法为什么不能调用非静态成员？" class="headerlink" title="静态方法为什么不能调用非静态成员？"></a>静态方法为什么不能调用非静态成员？</h2><p>需要结合JVM相关知识，主要原因如下：</p>
<ul>
<li>静态方法属于类的，在类加载的时候就会分配内存，可以通过类名直接访问；而非静态成员属于实例对象，只有在对象实例化后才会存在，需要通过类的实例对象去访问</li>
<li>在类的非静态成员变量不存在的时候静态方法已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</li>
</ul>
<h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul>
<li>调用方式：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象</li>
<li>访问类成员是否存在限制：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li>重载：发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同</li>
<li>重写: 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写</li>
</ul>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="对象实例与对象引用区别"><a href="#对象实例与对象引用区别" class="headerlink" title="对象实例与对象引用区别"></a>对象实例与对象引用区别</h2><ul>
<li>对象实例又new进行创建，对象实例存放在堆内存中</li>
<li>对象引用指向对象实例，对象引用存放在栈内存中</li>
<li>一个对象引用可以指向0个或者1个对象</li>
<li>一个对象实例可以有n个对象引用指向它</li>
</ul>
<h2 id="对象相等与引用相等的区别"><a href="#对象相等与引用相等的区别" class="headerlink" title="对象相等与引用相等的区别"></a>对象相等与引用相等的区别</h2><ul>
<li>对象的相等一般比较的是内存中存放的内存是否相等</li>
<li>引用相等一般是比较的是他们指向的内存地址是否相等<br>区分一下&#x3D;&#x3D;和equals的在对象中使用区别</li>
<li>&#x3D;&#x3D;运算符比较的是对象的引用是否相等</li>
<li>equals比较的是对象内容是否相等，比如：比较两个字符串的内容，即使两个字符串的对象引用不同，只要内容相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 == 比较字符串的引用相等</span></span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line"><span class="comment">// 使用 equals 方法比较字符串的相等</span></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str1.equals(str3));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出============</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类的构造方法可以不声明吗？"><a href="#类的构造方法可以不声明吗？" class="headerlink" title="类的构造方法可以不声明吗？"></a>类的构造方法可以不声明吗？</h2><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作<br>如果个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了<br>构造方法特点如下：</p>
<ul>
<li>名字与类名相同</li>
<li>没有返回值，单不能用void声明构造函数</li>
<li>生成类的对象是自动执行，无需调用<br>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</li>
</ul>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法，在子类中是无法访问的</li>
<li>子类可以拥有自己的属性和方法，即子类可对父类进行扩展</li>
<li>子类可以用自己的方式实现父类方法</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态表示一个对象具有多种状态，<strong>具体表现为使用父类的引用指向子类的实例</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承(类)&#x2F;实现(接口)的关系</li>
<li>引用类型变量发出的方法调用的是哪一个类中的方法，必须要在程序运行期间才能确定</li>
<li>多态不能调用“只在子类中存在但在父类中不存在”的方法</li>
<li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法</li>
</ul>
<h2 id="接口和抽象类的共同点和区别？"><a href="#接口和抽象类的共同点和区别？" class="headerlink" title="接口和抽象类的共同点和区别？"></a>接口和抽象类的共同点和区别？</h2><p>共同点：</p>
<ul>
<li>1.都不能被实例化</li>
<li>2.都可以包含抽象方法</li>
<li>3.都可以有默认的实现方法（Java 8可以使用default关键字在接口中定义默认的方法）</li>
</ul>
<p>区别：</p>
<ul>
<li>1.接口主要用于对类的行为进行约束，实现了某个接口就具有对应的行为；抽象类主要用于代码复用，强调的是所属关系</li>
<li>2.一个类只能继承一个抽象类，但可以实现多个接口</li>
<li>3.接口中的变量只能是public static final 类型的，不能被修改且必须有初始值；而抽象类的成员变量默认default，可以在子类中被重新定义，也可以被重新赋值</li>
</ul>
<h2 id="深浅拷贝的区别？什么是引用拷贝"><a href="#深浅拷贝的区别？什么是引用拷贝" class="headerlink" title="深浅拷贝的区别？什么是引用拷贝"></a>深浅拷贝的区别？什么是引用拷贝</h2><ul>
<li><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象的原对象共用一个内部对象<br>浅拷贝示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝：深拷贝会完全复制整个对象，包括这个对象锁包含的内部对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>引用拷贝：两个不同的引用指向同一个对象</p>
</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/MistletoeXW/image/master/image/shallow%26deep-copy.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/MistletoeXW/image/master/image/shallow%26deep-copy.png"  lazyload></a></p>
<h2 id="Object类常见的方法有哪些？"><a href="#Object类常见的方法有哪些？" class="headerlink" title="Object类常见的方法有哪些？"></a>Object类常见的方法有哪些？</h2><p>Object类是一个特殊的类，是所有类的父类，主要提供一下11个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native方法，用于返回当前运行时对象的class对象，使用了final关键字进行修饰，故不允许类重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写，以用于比较字符串的值是否相等</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法，用于创建并返回当前对象的一份拷贝</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回类的名字实例的哈希码的16进制</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="与equals-的区别"><a href="#与equals-的区别" class="headerlink" title="&#x3D;&#x3D;与equals()的区别"></a>&#x3D;&#x3D;与equals()的区别</h2><ul>
<li><p>&#x3D;&#x3D;对于基本类型和引用类型的作用效果是不同的</p>
<ul>
<li>对基本数据类型来说：&#x3D;&#x3D;比较是值</li>
<li>对引用数据类型来说：&#x3D;&#x3D;比较的是对象的内存地址<br>  因为Java只有值传递，所以，对&#x3D;&#x3D;来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址</li>
</ul>
</li>
<li><p>equals()不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或者间接父类，因此所有的类都有equals()方法；equals方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写equals方法</strong>：通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object类equals()方法</li>
<li><strong>类重写了equals方法</strong>：一般我们重写equals方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回true<br>  <strong>PS</strong>：String中的equals方法在内部是被重写过的，因为Object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象地址；当创建String类型的对象时，虚拟机会在常量池中查找到有没有已经存在的值和要创建的值相同的对象，如果有就将其赋值给引用；如果没有就在常量池中创建一个String对象</li>
</ul>
</li>
</ul>
<h2 id="hashCode-有什么作用"><a href="#hashCode-有什么作用" class="headerlink" title="hashCode()有什么作用?"></a>hashCode()有什么作用?</h2><p>hashCode()的作用是获取哈希码，也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置；hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。<br>以“HashSet”中如何检查重复为例来说明为什么要有hashCode<br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置<br>同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现<br>但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同<br>如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置<br>这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度<br>其实， hashCode() 和 equals()都是用于比较两个对象是否相等</p>
<p><strong>那为什么JDK要同时提供者两个方法？</strong><br>这是因为在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）</li>
<li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等</li>
<li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等</li>
</ul>
<h2 id="为什么重写equals-时必须要重写hashCode"><a href="#为什么重写equals-时必须要重写hashCode" class="headerlink" title="为什么重写equals()时必须要重写hashCode()?"></a>为什么重写equals()时必须要重写hashCode()?</h2><p>因为两个相等的对象的 hashCode 值必须是相等,也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等<br>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等<br><strong>总结</strong></p>
<ul>
<li>equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等</li>
<li>两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul>
<li>String 是不可变的</li>
<li>StringBuilder与StringBuffer都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法</li>
</ul>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ul>
<li>String 中的对象是不可变的，也就可以理解为常量，线程安全</li>
<li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全</li>
<li>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象</li>
<li>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用</li>
<li>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>操作少量的数据：使用String</li>
<li>单线程操作字符串缓冲去下大量数据: 使用StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ul>
<h2 id="String为什么是不可变的？"><a href="#String为什么是不可变的？" class="headerlink" title="String为什么是不可变的？"></a>String为什么是不可变的？</h2><p>首先，String中使用final关键字修饰字符数组来保存字符串，使用final关键字修饰有以下特点：</p>
<ul>
<li>final关键字修饰的类不能被继承</li>
<li>final关键字修饰的方法不能被重写</li>
<li>final关键字修饰基本数据类型的变量不能被改变</li>
<li>final关键字修饰的引用类型变量不能再指向其他对象<br>String不可变的原因如下：</li>
<li>保存字符串的数组被final修饰且为私有，并且String类没有提供修改这个字符串的方法</li>
<li>String类被final修饰导致其不能被继承，进而避免了子类破坏String不可变</li>
</ul>
<h2 id="字符串拼接使用-和StringBuilder的区别"><a href="#字符串拼接使用-和StringBuilder的区别" class="headerlink" title="字符串拼接使用+和StringBuilder的区别"></a>字符串拼接使用+和StringBuilder的区别</h2><ul>
<li>字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现，拼接完成之后调用 toString() 得到一个 String 对象</li>
<li>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象；如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题</li>
</ul>
<h2 id="String中的equals-和Object中equals-区别"><a href="#String中的equals-和Object中equals-区别" class="headerlink" title="String中的equals()和Object中equals()区别"></a>String中的equals()和Object中equals()区别</h2><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等<br>Object 的 equals 方法是比较的对象的内存地址</p>
<h2 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h2><p>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建</p>
<h2 id="String中的intern-的作用"><a href="#String中的intern-的作用" class="headerlink" title="String中的intern()的作用"></a>String中的intern()的作用</h2><p>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</li>
</ul>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="top-box-text">Java基础</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="top-box-text">Java中的基本类型</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">Java中基本类型和包装类型的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="top-box-text">包装类型的缓存机制了解吗？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="top-box-text">Java中自动装箱和拆箱？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">成员变量与局部变量的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="top-box-text">静态变量有什么作用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">字符型常量和字符串常量的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%9F"><span class="top-box-text">静态方法为什么不能调用非静态成员？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="top-box-text">静态方法和实例方法有何不同？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">重载和重写的区别</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="top-box-text">面向对象</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="top-box-text">对象实例与对象引用区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">对象相等与引用相等的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%A3%B0%E6%98%8E%E5%90%97%EF%BC%9F"><span class="top-box-text">类的构造方法可以不声明吗？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="top-box-text">面向对象三大特性</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B0%81%E8%A3%85"><span class="top-box-text">封装</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BB%A7%E6%89%BF"><span class="top-box-text">继承</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%9A%E6%80%81"><span class="top-box-text">多态</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="top-box-text">接口和抽象类的共同点和区别？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="top-box-text">深浅拷贝的区别？什么是引用拷贝</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Object%E7%B1%BB%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="top-box-text">Object类常见的方法有哪些？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%8Eequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">&#x3D;&#x3D;与equals()的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="top-box-text">hashCode()有什么作用?</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E8%A6%81%E9%87%8D%E5%86%99hashCode"><span class="top-box-text">为什么重写equals()时必须要重写hashCode()?</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#String"><span class="top-box-text">String</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">String、StringBuffer、StringBuilder的区别</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="top-box-text">可变性</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="top-box-text">线程安全性</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%80%A7%E8%83%BD"><span class="top-box-text">性能</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="top-box-text">String为什么是不可变的？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E4%BD%BF%E7%94%A8-%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">字符串拼接使用+和StringBuilder的区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#String%E4%B8%AD%E7%9A%84equals-%E5%92%8CObject%E4%B8%ADequals-%E5%8C%BA%E5%88%AB"><span class="top-box-text">String中的equals()和Object中equals()区别</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="top-box-text">字符串常量池的作用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#String%E4%B8%AD%E7%9A%84intern-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="top-box-text">String中的intern()的作用</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>

